.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::Chado::Schema::Result::Sequence::Feature 3"
.TH Bio::Chado::Schema::Result::Sequence::Feature 3 "2015-04-17" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::Chado::Schema::Result::Sequence::Feature
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A feature is a biological sequence or a
section of a biological sequence, or a collection of such
sections. Examples include genes, exons, transcripts, regulatory
regions, polypeptides, protein domains, chromosome sequences, sequence
variations, cross-genome match regions such as hits and HSPs and so
on; see the Sequence Ontology for more. The combination of
organism_id, uniquename and type_id should be unique.
.SH "ACCESSORS"
.IX Header "ACCESSORS"
.SS "feature_id"
.IX Subsection "feature_id"
.Vb 4
\&  data_type: \*(Aqinteger\*(Aq
\&  is_auto_increment: 1
\&  is_nullable: 0
\&  sequence: \*(Aqfeature_feature_id_seq\*(Aq
.Ve
.SS "dbxref_id"
.IX Subsection "dbxref_id"
.Vb 3
\&  data_type: \*(Aqinteger\*(Aq
\&  is_foreign_key: 1
\&  is_nullable: 1
.Ve
.PP
An optional primary public stable
identifier for this feature. Secondary identifiers and external
dbxrefs go in the table feature_dbxref.
.SS "organism_id"
.IX Subsection "organism_id"
.Vb 3
\&  data_type: \*(Aqinteger\*(Aq
\&  is_foreign_key: 1
\&  is_nullable: 0
.Ve
.PP
The organism to which this feature
belongs. This column is mandatory.
.SS "name"
.IX Subsection "name"
.Vb 3
\&  data_type: \*(Aqvarchar\*(Aq
\&  is_nullable: 1
\&  size: 255
.Ve
.PP
The optional human-readable common name for
a feature, for display purposes.
.SS "uniquename"
.IX Subsection "uniquename"
.Vb 2
\&  data_type: \*(Aqtext\*(Aq
\&  is_nullable: 0
.Ve
.PP
The unique name for a feature; may
not be necessarily be particularly human-readable, although this is
preferred. This name must be unique for this type of feature within
this organism.
.SS "residues"
.IX Subsection "residues"
.Vb 2
\&  data_type: \*(Aqtext\*(Aq
\&  is_nullable: 1
.Ve
.PP
A sequence of alphabetic characters
representing biological residues (nucleic acids, amino acids). This
column does not need to be manifested for all features; it is optional
for features such as exons where the residues can be derived from the
featureloc. It is recommended that the value for this column be
manifested for features which may may non-contiguous sublocations (e.g.
transcripts), since derivation at query time is non-trivial. For
expressed sequence, the \s-1DNA\s0 sequence should be used rather than the
\&\s-1RNA\s0 sequence. The default storage method for the residues column is
\&\s-1EXTERNAL,\s0 which will store it uncompressed to make substring operations
faster.
.SS "seqlen"
.IX Subsection "seqlen"
.Vb 2
\&  data_type: \*(Aqinteger\*(Aq
\&  is_nullable: 1
.Ve
.PP
The length of the residue feature. See
column:residues. This column is partially redundant with the residues
column, and also with featureloc. This column is required because the
location may be unknown and the residue sequence may not be
manifested, yet it may be desirable to store and query the length of
the feature. The seqlen should always be manifested where the length
of the sequence is known.
.SS "md5checksum"
.IX Subsection "md5checksum"
.Vb 3
\&  data_type: \*(Aqchar\*(Aq
\&  is_nullable: 1
\&  size: 32
.Ve
.PP
The 32\-character checksum of the sequence,
calculated using the \s-1MD5\s0 algorithm. This is practically guaranteed to
be unique for any feature. This column thus acts as a unique
identifier on the mathematical sequence.
.SS "type_id"
.IX Subsection "type_id"
.Vb 3
\&  data_type: \*(Aqinteger\*(Aq
\&  is_foreign_key: 1
\&  is_nullable: 0
.Ve
.PP
A required reference to a table:cvterm
giving the feature type. This will typically be a Sequence Ontology
identifier. This column is thus used to subclass the feature table.
.SS "is_analysis"
.IX Subsection "is_analysis"
.Vb 3
\&  data_type: \*(Aqboolean\*(Aq
\&  default_value: false
\&  is_nullable: 0
.Ve
.PP
Boolean indicating whether this
feature is annotated or the result of an automated analysis. Analysis
results also use the companalysis module. Note that the dividing line
between analysis and annotation may be fuzzy, this should be determined on
a per-project basis in a consistent manner. One requirement is that
there should only be one non-analysis version of each wild-type gene
feature in a genome, whereas the same gene feature can be predicted
multiple times in different analyses.
.SS "is_obsolete"
.IX Subsection "is_obsolete"
.Vb 3
\&  data_type: \*(Aqboolean\*(Aq
\&  default_value: false
\&  is_nullable: 0
.Ve
.PP
Boolean indicating whether this
feature has been obsoleted. Some chado instances may choose to simply
remove the feature altogether, others may choose to keep an obsolete
row in the table.
.SS "timeaccessioned"
.IX Subsection "timeaccessioned"
.Vb 4
\&  data_type: \*(Aqtimestamp\*(Aq
\&  default_value: current_timestamp
\&  is_nullable: 0
\&  original: {default_value => \e"now()"}
.Ve
.PP
For handling object
accession or modification timestamps (as opposed to database auditing data,
handled elsewhere). The expectation is that these fields would be
available to software interacting with chado.
.SS "timelastmodified"
.IX Subsection "timelastmodified"
.Vb 4
\&  data_type: \*(Aqtimestamp\*(Aq
\&  default_value: current_timestamp
\&  is_nullable: 0
\&  original: {default_value => \e"now()"}
.Ve
.PP
For handling object
accession or modification timestamps (as opposed to database auditing data,
handled elsewhere). The expectation is that these fields would be
available to software interacting with chado.
.SH "RELATIONS"
.IX Header "RELATIONS"
.SS "analysisfeatures"
.IX Subsection "analysisfeatures"
Type: has_many
.PP
Related object: Bio::Chado::Schema::Result::Companalysis::Analysisfeature
.SS "cell_line_features"
.IX Subsection "cell_line_features"
Type: has_many
.PP
Related object: Bio::Chado::Schema::Result::CellLine::CellLineFeature
.SS "elements"
.IX Subsection "elements"
Type: has_many
.PP
Related object: Bio::Chado::Schema::Result::Mage::Element
.SS "type"
.IX Subsection "type"
Type: belongs_to
.PP
Related object: Bio::Chado::Schema::Result::Cv::Cvterm
.SS "dbxref"
.IX Subsection "dbxref"
Type: belongs_to
.PP
Related object: Bio::Chado::Schema::Result::General::Dbxref
.SS "organism"
.IX Subsection "organism"
Type: belongs_to
.PP
Related object: Bio::Chado::Schema::Result::Organism::Organism
.SS "feature_cvterms"
.IX Subsection "feature_cvterms"
Type: has_many
.PP
Related object: Bio::Chado::Schema::Result::Sequence::FeatureCvterm
.SS "feature_dbxrefs"
.IX Subsection "feature_dbxrefs"
Type: has_many
.PP
Related object: Bio::Chado::Schema::Result::Sequence::FeatureDbxref
.SS "feature_expressions"
.IX Subsection "feature_expressions"
Type: has_many
.PP
Related object: Bio::Chado::Schema::Result::Expression::FeatureExpression
.SS "feature_genotype_features"
.IX Subsection "feature_genotype_features"
Type: has_many
.PP
Related object: Bio::Chado::Schema::Result::Genetic::FeatureGenotype
.SS "feature_genotype_chromosomes"
.IX Subsection "feature_genotype_chromosomes"
Type: has_many
.PP
Related object: Bio::Chado::Schema::Result::Genetic::FeatureGenotype
.SS "featureloc_features"
.IX Subsection "featureloc_features"
Type: has_many
.PP
Related object: Bio::Chado::Schema::Result::Sequence::Featureloc
.SS "featureloc_srcfeatures"
.IX Subsection "featureloc_srcfeatures"
Type: has_many
.PP
Related object: Bio::Chado::Schema::Result::Sequence::Featureloc
.SS "feature_phenotypes"
.IX Subsection "feature_phenotypes"
Type: has_many
.PP
Related object: Bio::Chado::Schema::Result::Phenotype::FeaturePhenotype
.SS "featurepos_feature"
.IX Subsection "featurepos_feature"
Type: has_many
.PP
Related object: Bio::Chado::Schema::Result::Map::Featurepos
.SS "featurepos_map_features"
.IX Subsection "featurepos_map_features"
Type: has_many
.PP
Related object: Bio::Chado::Schema::Result::Map::Featurepos
.SS "featureprops"
.IX Subsection "featureprops"
Type: has_many
.PP
Related object: Bio::Chado::Schema::Result::Sequence::Featureprop
.SS "feature_pubs"
.IX Subsection "feature_pubs"
Type: has_many
.PP
Related object: Bio::Chado::Schema::Result::Sequence::FeaturePub
.SS "featurerange_leftendfs"
.IX Subsection "featurerange_leftendfs"
Type: has_many
.PP
Related object: Bio::Chado::Schema::Result::Map::Featurerange
.SS "featurerange_rightstartfs"
.IX Subsection "featurerange_rightstartfs"
Type: has_many
.PP
Related object: Bio::Chado::Schema::Result::Map::Featurerange
.SS "featurerange_rightendfs"
.IX Subsection "featurerange_rightendfs"
Type: has_many
.PP
Related object: Bio::Chado::Schema::Result::Map::Featurerange
.SS "featurerange_leftstartfs"
.IX Subsection "featurerange_leftstartfs"
Type: has_many
.PP
Related object: Bio::Chado::Schema::Result::Map::Featurerange
.SS "featurerange_features"
.IX Subsection "featurerange_features"
Type: has_many
.PP
Related object: Bio::Chado::Schema::Result::Map::Featurerange
.SS "feature_relationship_subjects"
.IX Subsection "feature_relationship_subjects"
Type: has_many
.PP
Related object: Bio::Chado::Schema::Result::Sequence::FeatureRelationship
.SS "feature_relationship_objects"
.IX Subsection "feature_relationship_objects"
Type: has_many
.PP
Related object: Bio::Chado::Schema::Result::Sequence::FeatureRelationship
.SS "feature_synonyms"
.IX Subsection "feature_synonyms"
Type: has_many
.PP
Related object: Bio::Chado::Schema::Result::Sequence::FeatureSynonym
.SS "library_features"
.IX Subsection "library_features"
Type: has_many
.PP
Related object: Bio::Chado::Schema::Result::Library::LibraryFeature
.SS "phylonodes"
.IX Subsection "phylonodes"
Type: has_many
.PP
Related object: Bio::Chado::Schema::Result::Phylogeny::Phylonode
.SS "studyprop_features"
.IX Subsection "studyprop_features"
Type: has_many
.PP
Related object: Bio::Chado::Schema::Result::Mage::StudypropFeature
.SH "ADDITIONAL RELATIONSHIPS"
.IX Header "ADDITIONAL RELATIONSHIPS"
.SS "parent_relationships"
.IX Subsection "parent_relationships"
Type: has_to_many
.PP
Returns a list of parent relationships.
.PP
Related object: Bio::Chado::Schema::Result::Sequence::FeatureRelationship
.SS "child_relationships"
.IX Subsection "child_relationships"
Type: has_to_many
.PP
Returns a list of child relationships.
.PP
Related object: Bio::Chado::Schema::Result::Sequence::FeatureRelationship
.SS "primary_dbxref"
.IX Subsection "primary_dbxref"
Alias for dbxref
.SH "MANY-TO-MANY RELATIONSHIPS"
.IX Header "MANY-TO-MANY RELATIONSHIPS"
.SS "parent_features"
.IX Subsection "parent_features"
Type: many_to_many
.PP
Returns a list of parent features (i.e. features that are the
\&\fBobject\fR of feature_relationship rows in which this feature is the
\&\fBsubject\fR).
.PP
Related object: Bio::Chado::Schema::Result::Sequence::Feature
.SS "child_features"
.IX Subsection "child_features"
Type: many_to_many
.PP
Returns a list of child features (i.e. features that are the
\&\fBsubject\fR of feature_relationship rows in which this feature is the
\&\fBobject\fR).
.PP
Related object: Bio::Chado::Schema::Result::Sequence::Feature
.SS "synonyms"
.IX Subsection "synonyms"
Type: many_to_many
.PP
Related object: Bio::Chado::Schema::Result::Sequence::Synonym
.SS "dbxrefs_mm"
.IX Subsection "dbxrefs_mm"
Type: many_to_many
.PP
Related object: Bio::Chado::Schema::Result::General::Dbxref (i.e. dbxref
table) Bio::Chado::Schema::Result::Sequence::FeatureDbxref (feature_dbxref
table)
.SS "secondary_dbxrefs"
.IX Subsection "secondary_dbxrefs"
Alias for dbxrefs_mm
.SH "ADDITIONAL METHODS"
.IX Header "ADDITIONAL METHODS"
.SS "create_featureprops"
.IX Subsection "create_featureprops"
.Vb 10
\&  Usage: $set\->create_featureprops({ baz => 2, foo => \*(Aqbar\*(Aq });
\&  Desc : convenience method to create feature properties using cvterms
\&          from the ontology with the given name
\&  Args : hashref of { propname => value, ...},
\&         options hashref as:
\&          {
\&            autocreate => 0,
\&               (optional) boolean, if passed, automatically create cv,
\&               cvterm, and dbxref rows if one cannot be found for the
\&               given featureprop name.  Default false.
\&
\&            cv_name => cv.name to use for the given featureprops.
\&                       Defaults to \*(Aqfeature_property\*(Aq,
\&
\&            db_name => db.name to use for autocreated dbxrefs,
\&                       default \*(Aqnull\*(Aq,
\&
\&            dbxref_accession_prefix => optional, default
\&                                       \*(Aqautocreated:\*(Aq,
\&            definitions => optional hashref of:
\&                { cvterm_name => definition,
\&                }
\&             to load into the cvterm table when autocreating cvterms
\&
\&             allow_duplicate_values => default false.
\&                If true, allow duplicate instances of the same cvterm
\&                and value in the properties of the feature.  Duplicate
\&                values will have different ranks.
\&          }
\&  Ret  : hashref of { propname => new featureprop object }
.Ve
.SS "search_featureprops"
.IX Subsection "search_featureprops"
.Vb 9
\&  Status  : public
\&  Usage   : $feat\->search_featureprops( \*(Aqdescription\*(Aq )
\&            # OR
\&            $feat\->search_featureprops({ name => \*(Aqdescription\*(Aq})
\&  Returns : DBIx::Class::ResultSet like other search() methods
\&  Args    : single string to match cvterm name,
\&            or hashref of search criteria.  This is passed
\&            to $chado\->resultset(\*(AqCv::Cvterm\*(Aq)
\&                     \->search({ your criteria })
\&
\&  Convenience method to search featureprops for a feature that
\&  match to Cvterms having the given criterion hash
.Ve
.SH "Bio::PrimarySeqI METHODS"
.IX Header "Bio::PrimarySeqI METHODS"
The methods below are intended to provide some compatibility with
BioPerl's Bio::PrimarySeqI interface, so that a feature may be used
as a sequence.  Note that Bio::PrimarySeqI only provides
identifier, accession, and sequence information, no subfeatures,
ranges, or the like.
.PP
Support for BioPerl's more complete Bio::SeqI interface, which
includes those things, still needs to be implemented.  If you are
interested in helping with this, please contact \s-1GMOD\s0!
.SS "id, primary_id, display_id"
.IX Subsection "id, primary_id, display_id"
These are aliases for \fIname()\fR, which just returns the contents of the
feature.name field
.SS "seq"
.IX Subsection "seq"
.Vb 1
\&  Alias for $feature\->residues()
.Ve
.ie n .SS "subseq( $start, $end )"
.el .SS "subseq( \f(CW$start\fP, \f(CW$end\fP )"
.IX Subsection "subseq( $start, $end )"
Same as Bio::PrimarySeq subseq method, with one important exception.
If the residues column is not set (null) for this feature, it checks
for a featureprop of type \f(CW\*(C`large_residues\*(C'\fR (irrespective of the
type's \s-1CV\s0 membership), and uses its value as the sequence if
it is present.
.PP
So, you can store large (i.e. megabase or greater) sequences in a
\&\f(CW\*(C`large_residues\*(C'\fR featureprop, and use this \f(CW\*(C`subseq()\*(C'\fR method to
fetch pieces of them, with the sequences never being entirely stored
in memory or transferred in total from the database server to the app
server.  This is implemented behind the scenes by using \s-1SQL\s0 substring
operations on the featureprop's value.
.SS "trunc"
.IX Subsection "trunc"
Same as subseq above, but return a sequence object rather than a bare string.
.SS "accession, accession_number"
.IX Subsection "accession, accession_number"
.Vb 8
\&  Usage: say $feature\->accession_number
\&  Desc : get an "<accession>.<version>"\-style string.  gets this from
\&         either the primary dbxref, or the first secondary_dbxref
\&         found
\&  Args : none
\&  Ret : string of the form "accession.version" formed from the
\&        accession and version fields of either the primary or
\&        secondary dbxrefs
.Ve
.SS "length"
.IX Subsection "length"
No arguments, returns the \fIseqlen()\fR, or length( \f(CW$feature\fR\->residues ) if
that is not defined.
.SS "desc, description"
.IX Subsection "desc, description"
No arguments, returns the value of the first 'description' featureprop
found for this feature.
.SS "alphabet"
.IX Subsection "alphabet"
Returns \*(L"protein\*(R" if the feature's type name is \*(L"polypeptide\*(R".
Otherwise, returns \*(L"dna\*(R".  This is not very correct, but works in most
of the use cases we've seen so far.
